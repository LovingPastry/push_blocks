<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>推推俄罗斯 - 历史记录版</title>
    <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #0f172a; touch-action: none; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #game-container { position: relative; width: 100vw; height: 100vh; background: #0f172a; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; z-index: 10; }
        
        .top-bar { display: flex; justify-content: space-between; align-items: flex-start; width: 100%; flex-wrap: wrap; gap: 10px; }
        
        .score-board { color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .level-text { font-size: 28px; font-weight: bold; color: #fbbf24; }
        .time-text { font-size: 16px; color: #9ca3af; }
        .debug-text { font-size: 12px; color: #4b5563; margin-top: 5px;}
        .accuracy-bar { width: 160px; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-top: 10px; overflow: hidden; display: none; }
        .accuracy-fill { height: 100%; background: #22c55e; width: 0%; transition: width 0.1s; }

        .controls-area { display: flex; flex-direction: column; align-items: flex-end; gap: 8px; pointer-events: auto; }

        .btn-group { display: flex; gap: 8px; }

        .game-btn {
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 6px 12px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 13px;
            color: white;
            white-space: nowrap;
        }
        .game-btn:active { transform: scale(0.95); }
        .game-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        
        .btn-prev { background: rgba(100, 116, 139, 0.2); color: #cbd5e1; border-color: rgba(148, 163, 184, 0.5); }
        .btn-prev:hover:not(:disabled) { background: rgba(100, 116, 139, 0.8); color: white; }

        .btn-retry { background: rgba(239, 68, 68, 0.2); color: #fca5a5; border-color: rgba(239, 68, 68, 0.5); }
        .btn-retry:hover:not(:disabled) { background: rgba(239, 68, 68, 0.8); color: white; }

        .btn-skip { background: rgba(59, 130, 246, 0.2); color: #93c5fd; border-color: rgba(59, 130, 246, 0.5); }
        .btn-skip:hover:not(:disabled) { background: rgba(59, 130, 246, 0.8); color: white; }

        .difficulty-select {
            appearance: none;
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(148, 163, 184, 0.5);
            color: #e2e8f0;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            outline: none;
            text-align: right;
            backdrop-filter: blur(4px);
        }
        .difficulty-select:hover { border-color: #fbbf24; }
        .difficulty-wrapper { position: relative; display: flex; align-items: center; gap: 5px; }
        .difficulty-label { color: #94a3b8; font-size: 12px; font-weight: bold; text-transform: uppercase; }

        .instruction { color: rgba(255,255,255,0.7); text-align: center; font-size: 16px; margin-bottom: 20px; background: rgba(0,0,0,0.3); padding: 10px 20px; border-radius: 999px; align-self: center; pointer-events: auto; cursor: pointer; backdrop-filter: blur(2px);}
        
        #win-message { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            font-size: 4rem; color: #4ade80; font-weight: 900; 
            text-shadow: 0 0 30px rgba(74, 222, 128, 0.6); 
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
            text-align: center; white-space: nowrap; z-index: 20;
        }

        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #0f172a; z-index: 50; display: flex; align-items: center; justify-content: center;
            color: white; font-size: 20px; flex-direction: column;
        }
        .spinner { border: 4px solid rgba(255,255,255,0.1); border-left-color: #fbbf24; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="loading-screen">
    <div class="spinner"></div>
    <div id="loading-text">加载物理引擎...</div>
</div>

<div id="game-container">
    <div id="win-message">PERFECT!</div>
    <div id="ui-layer">
        <div class="top-bar">
            <div class="score-board">
                <div class="level-text">Stage <span id="level-display">1</span></div>
                <div class="time-text">Time: <span id="timer-display">0.0</span>s</div>
                <div class="debug-text">Req: >95% Overlap</div>
                <div class="accuracy-bar" id="acc-bar"><div class="accuracy-fill" id="acc-fill"></div></div>
            </div>
            
            <div class="controls-area">
                <div class="difficulty-wrapper">
                    <span class="difficulty-label">方块规模</span>
                    <select id="difficulty-select" class="difficulty-select" onchange="onDifficultyChange()">
                        <option value="1">1 (单格)</option>
                        <option value="2">2 (多米诺)</option>
                        <option value="3">3 (三格)</option>
                        <option value="4" selected>4 (经典)</option>
                        <option value="5">5 (五格)</option>
                    </select>
                </div>

                <div class="btn-group">
                    <!-- 上一关 -->
                    <button onclick="goToPreviousLevel()" class="game-btn btn-prev" id="btn-prev" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" />
                        </svg>
                        上一关
                    </button>
                    <!-- 重置 -->
                    <button onclick="retryCurrentLevel()" class="game-btn btn-retry">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                        </svg>
                        重置
                    </button>
                    <!-- 下一关 -->
                    <button onclick="goToNextLevel()" class="game-btn btn-skip">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
                        </svg>
                        下一关
                    </button>
                </div>
            </div>
        </div>

        <div class="instruction" onclick="toggleInstruction()">
            推方块入框<br>需<b>精准重合</b>
        </div>
    </div>
</div>

<script>
    // --- 游戏引擎配置 ---
    const LOGICAL_SIZE = 1000; 
    const ARENA_SIZE = 800;    
    const CENTER = LOGICAL_SIZE / 2;
    
    const ENGINE_CONFIG = {
        wallThickness: 100,
        playerSize: 17.5, 
        blockSize: 35, 
        winDistance: 5.0, 
        winAngle: 0.08, 
    };

    // --- 方块数据库 ---
    const POLYOMINO_SETS = {
        '1': { 'Mono': { color: '#94a3b8', symmetry: Math.PI / 2, blocks: [{x:0, y:0}] } },
        '2': { 'Domino': { color: '#60a5fa', symmetry: Math.PI, blocks: [{x:-0.5, y:0}, {x:0.5, y:0}] } },
        '3': {
            'I3': { color: '#22d3ee', symmetry: Math.PI, blocks: [{x:-1, y:0}, {x:0, y:0}, {x:1, y:0}] },
            'L3': { color: '#facc15', symmetry: Math.PI * 2, blocks: [{x:-0.5, y:-0.5}, {x:0.5, y:-0.5}, {x:-0.5, y:0.5}] }
        },
        '4': {
            'I': { color: '#22d3ee', symmetry: Math.PI, blocks: [{x:-1.5, y:0}, {x:-0.5, y:0}, {x:0.5, y:0}, {x:1.5, y:0}] },
            'J': { color: '#3b82f6', symmetry: Math.PI * 2, blocks: [{x:-1, y:-0.5}, {x:0, y:-0.5}, {x:1, y:-0.5}, {x:1, y:0.5}] },
            'L': { color: '#f59e0b', symmetry: Math.PI * 2, blocks: [{x:-1, y:0.5}, {x:-1, y:-0.5}, {x:0, y:-0.5}, {x:1, y:-0.5}] },
            'O': { color: '#eab308', symmetry: Math.PI / 2, blocks: [{x:-0.5, y:-0.5}, {x:0.5, y:-0.5}, {x:-0.5, y:0.5}, {x:0.5, y:0.5}] },
            'S': { color: '#22c55e', symmetry: Math.PI, blocks: [{x:-0.5, y:0.5}, {x:0.5, y:0.5}, {x:0.5, y:-0.5}, {x:1.5, y:-0.5}] },
            'T': { color: '#a855f7', symmetry: Math.PI * 2, blocks: [{x:-0.5, y:-0.5}, {x:0.5, y:-0.5}, {x:1.5, y:-0.5}, {x:0.5, y:0.5}] },
            'Z': { color: '#ef4444', symmetry: Math.PI, blocks: [{x:-1.5, y:-0.5}, {x:-0.5, y:-0.5}, {x:-0.5, y:0.5}, {x:0.5, y:0.5}] }
        },
        '5': {
            'I5': { color: '#06b6d4', symmetry: Math.PI, blocks: [{x:-2,y:0}, {x:-1,y:0}, {x:0,y:0}, {x:1,y:0}, {x:2,y:0}] },
            'L5': { color: '#f59e0b', symmetry: Math.PI * 2, blocks: [{x:-1.5,y:0.5}, {x:-0.5,y:0.5}, {x:0.5,y:0.5}, {x:1.5,y:0.5}, {x:-1.5,y:-0.5}] },
            'P': { color: '#ec4899', symmetry: Math.PI * 2, blocks: [{x:-0.5,y:-1}, {x:-0.5,y:0}, {x:-0.5,y:1}, {x:0.5,y:0}, {x:0.5,y:1}] },
            'T5': { color: '#a855f7', symmetry: Math.PI * 2, blocks: [{x:-1,y:-0.5}, {x:0,y:-0.5}, {x:1,y:-0.5}, {x:0,y:0.5}, {x:0,y:1.5}] },
            'U': { color: '#84cc16', symmetry: Math.PI * 2, blocks: [{x:-1,y:-1}, {x:-1,y:0.5}, {x:0,y:0.5}, {x:1,y:0.5}, {x:1,y:-1}] },
            'V': { color: '#ef4444', symmetry: Math.PI * 2, blocks: [{x:-1,y:-1}, {x:-1,y:0}, {x:-1,y:1}, {x:0,y:1}, {x:1,y:1}] },
            'W': { color: '#14b8a6', symmetry: Math.PI * 2, blocks: [{x:-1,y:-1}, {x:-1,y:0}, {x:0,y:0}, {x:0,y:1}, {x:1,y:1}] },
            'X': { color: '#6366f1', symmetry: Math.PI / 2, blocks: [{x:0,y:0}, {x:-1,y:0}, {x:1,y:0}, {x:0,y:-1}, {x:0,y:1}] },
            'Y': { color: '#eab308', symmetry: Math.PI * 2, blocks: [{x:-1.5,y:0}, {x:-0.5,y:0}, {x:0.5,y:0}, {x:1.5,y:0}, {x:0.5,y:-1}] },
            'Z5': { color: '#f97316', symmetry: Math.PI, blocks: [{x:-1,y:-1}, {x:0,y:-1}, {x:0,y:0}, {x:0,y:1}, {x:1,y:1}] },
            'F': { color: '#8b5cf6', symmetry: Math.PI * 2, blocks: [{x:0,y:-1}, {x:0,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:1,y:-1}] },
            'N': { color: '#3b82f6', symmetry: Math.PI, blocks: [{x:-1.5,y:0.5}, {x:-0.5,y:0.5}, {x:-0.5,y:-0.5}, {x:0.5,y:-0.5}, {x:1.5,y:-0.5}] }
        }
    };

    Object.keys(POLYOMINO_SETS).forEach(n => {
        const set = POLYOMINO_SETS[n];
        Object.keys(set).forEach(key => {
            const blocks = set[key].blocks;
            let sumX = 0, sumY = 0;
            blocks.forEach(b => { sumX += b.x; sumY += b.y; });
            set[key].offset = { x: sumX / blocks.length, y: sumY / blocks.length };
        });
    });

    let Engine, Render, Runner, Bodies, Body, Composite, Events, Vector;
    let engine, render, runner;
    let playerBody, activeTetrominoBody = null, targetZone = null;
    let isDragging = false;
    let screenMouse = { x: 0, y: 0 };
    let worldMouse = { x: 0, y: 0 };
    let startTime = Date.now(), isWinning = false;
    let currentDifficulty = '4';

    // --- 历史记录系统 ---
    let levelHistory = []; // 存储所有生成的关卡配置
    let currentHistoryIndex = -1; // 当前处于历史记录的哪个位置

    function checkResourcesAndInit() {
        if (typeof Matter === 'undefined') {
            document.getElementById('loading-text').innerText = "加载失败: 无法连接 CDN。\n请尝试刷新或检查网络。";
            return;
        }
        Engine = Matter.Engine;
        Render = Matter.Render;
        Runner = Matter.Runner;
        Bodies = Matter.Bodies;
        Body = Matter.Body;
        Composite = Matter.Composite;
        Events = Matter.Events;
        Vector = Matter.Vector;
        initGame();
    }

    function initGame() {
        const container = document.getElementById('game-container');
        const loadingScreen = document.getElementById('loading-screen');
        if (container.clientWidth === 0) { setTimeout(initGame, 100); return; }
        loadingScreen.style.opacity = 0;
        setTimeout(() => loadingScreen.style.display = 'none', 500);

        engine = Engine.create({ gravity: { x: 0, y: 0, scale: 0 } });

        render = Render.create({
            element: container,
            engine: engine,
            options: {
                width: container.clientWidth,
                height: container.clientHeight,
                wireframes: false,
                background: '#0f172a',
                pixelRatio: Math.min(window.devicePixelRatio, 2),
                hasBounds: true 
            }
        });

        createFixedWalls();

        playerBody = Bodies.circle(CENTER, CENTER + 200, ENGINE_CONFIG.playerSize, {
            density: 0.005,
            frictionAir: 0.15,
            restitution: 0.4,
            render: { fillStyle: '#ffffff', strokeStyle: '#e5e7eb', lineWidth: 4 },
            label: 'Player'
        });
        Composite.add(engine.world, playerBody);

        setupInputs(render.canvas);
        setupEvents();

        Runner.run(Runner.create(), engine);
        Render.run(render);

        // 初始化难度并开始
        onDifficultyChange(true); 
        window.addEventListener('resize', updateViewport);
        updateViewport();
    }

    function onDifficultyChange(isInit = false) {
        const select = document.getElementById('difficulty-select');
        currentDifficulty = select.value;
        // 切换难度时，清空历史，重新开始
        if (!isInit) {
            levelHistory = [];
            currentHistoryIndex = -1;
            goToNextLevel();
        } else {
            // 初始化直接生成第一关
            goToNextLevel(); 
        }
    }

    // --- 关卡流控制 ---

    // 1. 上一关
    function goToPreviousLevel() {
        if (currentHistoryIndex > 0) {
            currentHistoryIndex--;
            loadLevelFromState(levelHistory[currentHistoryIndex]);
        }
    }

    // 2. 下一关 (如果已在最新关则生成新关，否则从历史加载)
    function goToNextLevel() {
        if (currentHistoryIndex < levelHistory.length - 1) {
            // 仅仅是往后翻页，读取历史
            currentHistoryIndex++;
            loadLevelFromState(levelHistory[currentHistoryIndex]);
        } else {
            // 确实是新的一关，生成并保存
            generateAndLoadNewLevel();
        }
    }

    // 3. 重置当前关卡 (从历史记录重新加载当前状态)
    function retryCurrentLevel() {
        if (currentHistoryIndex >= 0 && currentHistoryIndex < levelHistory.length) {
            loadLevelFromState(levelHistory[currentHistoryIndex]);
        }
    }

    // 辅助：生成新关卡数据并入栈
    function generateAndLoadNewLevel() {
        const spawnMargin = 150; 
        const range = ARENA_SIZE / 2 - spawnMargin;

        const playerX = CENTER + (Math.random() - 0.5) * 2 * range;
        const playerY = CENTER + (Math.random() - 0.5) * 2 * range;

        const diff = currentDifficulty; 
        const currentSet = POLYOMINO_SETS[diff];
        const keys = Object.keys(currentSet);
        const type = keys[Math.floor(Math.random() * keys.length)];

        const targetX = CENTER + (Math.random() - 0.5) * 2 * range;
        const targetY = CENTER + (Math.random() - 0.5) * 2 * range; 
        const targetAngle = (Math.floor(Math.random() * 4) * 90) * (Math.PI / 180);

        let startX, startY, isSafe = false, attempts = 0;
        while (!isSafe && attempts < 50) {
            startX = CENTER + (Math.random() - 0.5) * 2 * range;
            startY = CENTER + (Math.random() - 0.5) * 2 * range;
            const distP = Math.hypot(startX - playerX, startY - playerY);
            const distT = Math.hypot(startX - targetX, startY - targetY);
            if (distP > 160 && distT > 160) isSafe = true; 
            attempts++;
        }
        
        const initialAngle = Math.random() * Math.PI * 2;

        // 构建状态对象
        const newState = {
            playerStart: { x: playerX, y: playerY },
            blockStart: { x: startX, y: startY },
            blockType: type,
            blockSet: diff,
            blockInitialAngle: initialAngle,
            targetZone: { x: targetX, y: targetY, angle: targetAngle, type: type, diff: diff }
        };

        // 入栈
        levelHistory.push(newState);
        currentHistoryIndex++;

        // 加载
        loadLevelFromState(newState);
    }

    // 辅助：根据状态加载关卡 (物理实体生成)
    function loadLevelFromState(state) {
        // UI 更新
        isWinning = false;
        document.getElementById('win-message').style.opacity = 0;
        document.getElementById('acc-bar').style.display = 'block'; 
        // 显示当前是第几关 (Index + 1)
        document.getElementById('level-display').innerText = currentHistoryIndex + 1;
        
        // 控制按钮状态
        const btnPrev = document.getElementById('btn-prev');
        if (btnPrev) {
            btnPrev.disabled = (currentHistoryIndex <= 0);
        }

        // 物理清理
        Composite.allBodies(engine.world).forEach(b => {
            if (b.label === 'Tetromino') Composite.remove(engine.world, b);
        });

        // 恢复数据
        targetZone = state.targetZone;

        // 恢复实体
        Body.setPosition(playerBody, state.playerStart);
        Body.setVelocity(playerBody, { x: 0, y: 0 });
        Body.setAngularVelocity(playerBody, 0);

        activeTetrominoBody = createPolyomino(
            state.blockStart.x, 
            state.blockStart.y, 
            state.blockSet, 
            state.blockType
        );
        Body.setAngle(activeTetrominoBody, state.blockInitialAngle);
        Composite.add(engine.world, activeTetrominoBody);
        
        startTime = Date.now();
    }

    // --- 物理与渲染逻辑 --- (保持不变)

    function updateViewport() {
        const container = document.getElementById('game-container');
        const w = container.clientWidth;
        const h = container.clientHeight;
        const pixelRatio = render.options.pixelRatio;

        render.canvas.width = w * pixelRatio;
        render.canvas.height = h * pixelRatio;
        render.canvas.style.width = w + 'px';
        render.canvas.style.height = h + 'px';
        render.options.width = w;
        render.options.height = h;

        const padding = 0.9; 
        const minDimension = Math.min(w, h);
        const scaleFactor = (ARENA_SIZE / padding) / minDimension;
        
        const viewWidth = w * scaleFactor;
        const viewHeight = h * scaleFactor;

        render.bounds.min.x = CENTER - viewWidth / 2;
        render.bounds.max.x = CENTER + viewWidth / 2;
        render.bounds.min.y = CENTER - viewHeight / 2;
        render.bounds.max.y = CENTER + viewHeight / 2;
        
        updateMouseWorldPosition();
    }

    function createFixedWalls() {
        const thick = ENGINE_CONFIG.wallThickness;
        const wallColor = '#334155';
        const wallOpts = { isStatic: true, render: { fillStyle: wallColor } };
        const half = ARENA_SIZE / 2;
        
        const walls = [
            Bodies.rectangle(CENTER, CENTER - half - thick/2, ARENA_SIZE + thick*2, thick, wallOpts),
            Bodies.rectangle(CENTER, CENTER + half + thick/2, ARENA_SIZE + thick*2, thick, wallOpts),
            Bodies.rectangle(CENTER - half - thick/2, CENTER, thick, ARENA_SIZE, wallOpts),
            Bodies.rectangle(CENTER + half + thick/2, CENTER, thick, ARENA_SIZE, wallOpts)
        ];
        Composite.add(engine.world, walls);
    }

    function setupInputs(canvas) {
        const handleInput = (e) => {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            screenMouse.x = x;
            screenMouse.y = y;
            isDragging = (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'touchmove' || (e.type === 'mousemove' && isDragging));
            
            if (e.type === 'mouseup' || e.type === 'touchend') {
                isDragging = false;
            }
            
            updateMouseWorldPosition();
        };

        canvas.addEventListener('mousedown', (e) => { isDragging = true; handleInput(e); });
        window.addEventListener('mousemove', handleInput);
        window.addEventListener('mouseup', (e) => { isDragging = false; });
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); isDragging = true; handleInput(e); }, {passive: false});
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleInput(e); }, {passive: false});
        canvas.addEventListener('touchend', (e) => { isDragging = false; });
    }

    function updateMouseWorldPosition() {
        if (!render) return;
        const container = document.getElementById('game-container');
        const w = container.clientWidth;
        const h = container.clientHeight;
        const bounds = render.bounds;
        const scaleX = (bounds.max.x - bounds.min.x) / w;
        const scaleY = (bounds.max.y - bounds.min.y) / h;
        worldMouse.x = bounds.min.x + screenMouse.x * scaleX;
        worldMouse.y = bounds.min.y + screenMouse.y * scaleY;
    }

    function setupEvents() {
        Events.on(engine, 'beforeUpdate', function() {
            engine.world.gravity.scale = 0;
            if (isDragging && playerBody) {
                const forceVector = Vector.sub(worldMouse, playerBody.position);
                const forceMagnitude = Vector.magnitude(forceVector);
                const maxForce = 0.005 * playerBody.mass;
                const normalizedForce = Vector.normalise(forceVector);
                const appliedForce = Vector.mult(normalizedForce, Math.min(forceMagnitude * 0.0015, maxForce));
                Body.applyForce(playerBody, playerBody.position, appliedForce);
            }
            checkWinCondition();
        });

        Events.on(engine, 'afterUpdate', function() {
            const margin = ENGINE_CONFIG.wallThickness + 50;
            const min = CENTER - ARENA_SIZE/2 - margin;
            const max = CENTER + ARENA_SIZE/2 + margin;
            function check(body) {
                if(!body) return;
                if(body.position.x < min || body.position.x > max || body.position.y < min || body.position.y > max) {
                    Body.setPosition(body, {x: CENTER, y: CENTER});
                    Body.setVelocity(body, {x:0, y:0});
                }
            }
            check(playerBody);
            check(activeTetrominoBody);
        });

        Events.on(render, 'afterRender', function() {
            const ctx = render.context;
            Render.startViewTransform(render);
            renderOverlay(ctx);
            Render.endViewTransform(render);
            if (!isWinning) {
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                document.getElementById('timer-display').innerText = elapsed;
            }
        });
    }

    function renderOverlay(ctx) {
        if (!targetZone) return;

        ctx.save();
        ctx.translate(targetZone.x, targetZone.y);
        ctx.rotate(targetZone.angle);
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.lineWidth = 2; 
        ctx.setLineDash([8, 6]); 
        
        const set = POLYOMINO_SETS[targetZone.diff];
        const config = set[targetZone.type];
        const blocks = config.blocks;
        const offset = config.offset; 
        const size = ENGINE_CONFIG.blockSize; 

        blocks.forEach(block => {
            const bx = (block.x - offset.x) * size;
            const by = (block.y - offset.y) * size;
            ctx.strokeRect(bx - size/2, by - size/2, size, size);
            ctx.fillStyle = config.color + '22'; 
            ctx.fillRect(bx - size/2, by - size/2, size, size);
        });
        ctx.restore();
        
        if (isDragging) {
            ctx.beginPath();
            ctx.moveTo(playerBody.position.x, playerBody.position.y);
            ctx.lineTo(worldMouse.x, worldMouse.y);
            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([]);
            ctx.stroke();
        }
    }

    function createPolyomino(x, y, diff, type) {
        const config = POLYOMINO_SETS[diff][type];
        const parts = [];
        config.blocks.forEach(b => {
            parts.push(Bodies.rectangle(
                x + b.x * ENGINE_CONFIG.blockSize, 
                y + b.y * ENGINE_CONFIG.blockSize, 
                ENGINE_CONFIG.blockSize, 
                ENGINE_CONFIG.blockSize,
                { render: { fillStyle: config.color, strokeStyle: '#000', lineWidth: 1 } }
            ));
        });
        return Body.create({
            parts: parts,
            frictionAir: 0.1, 
            restitution: 0.1, 
            density: 0.002,
            label: 'Tetromino'
        });
    }

    function checkWinCondition() {
        if (isWinning || !activeTetrominoBody || !targetZone) return;

        const pos = activeTetrominoBody.position;
        const dist = Vector.magnitude(Vector.sub(pos, {x: targetZone.x, y: targetZone.y}));
        
        let currentAngle = activeTetrominoBody.angle;
        let targetA = targetZone.angle;
        
        const symmetry = POLYOMINO_SETS[targetZone.diff][targetZone.type].symmetry;
        
        let angleDiff = Math.abs(currentAngle - targetA);
        angleDiff = angleDiff % symmetry;
        if (angleDiff > symmetry / 2) {
            angleDiff = symmetry - angleDiff;
        }

        const speed = Vector.magnitude(activeTetrominoBody.velocity);
        const angularSpeed = Math.abs(activeTetrominoBody.angularVelocity);

        const accuracy = Math.max(0, 1 - (dist / 100) - (angleDiff / 1.0));
        const barFill = document.getElementById('acc-fill');
        if(barFill) barFill.style.width = (accuracy * 100) + '%';
        if(accuracy > 0.9) barFill.style.background = '#4ade80';
        else barFill.style.background = '#ef4444';

        if (dist < ENGINE_CONFIG.winDistance && angleDiff < ENGINE_CONFIG.winAngle && speed < 1.0 && angularSpeed < 0.05) {
             victory();
        }
    }

    function victory() {
        isWinning = true;
        document.getElementById('win-message').style.opacity = 1;
        document.getElementById('acc-bar').style.display = 'none';
        
        Body.setPosition(activeTetrominoBody, {x: targetZone.x, y: targetZone.y});
        Body.setAngle(activeTetrominoBody, targetZone.angle);
        Body.setStatic(activeTetrominoBody, true); 
        activeTetrominoBody.render.opacity = 0.5;

        setTimeout(() => {
            goToNextLevel();
        }, 2000); 
    }

    function toggleInstruction() {
        document.querySelector('.instruction').style.display = 'none';
    }

    window.onload = checkResourcesAndInit;

</script>
</body>
</html>