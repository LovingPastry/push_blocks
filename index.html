<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>推推俄罗斯 - 双重置版</title>
    <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #0f172a; touch-action: none; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #game-container { position: relative; width: 100vw; height: 100vh; background: #0f172a; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; z-index: 10; }
        
        .top-bar { display: flex; justify-content: space-between; align-items: flex-start; width: 100%; }
        
        .score-board { color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .level-text { font-size: 28px; font-weight: bold; color: #fbbf24; }
        .time-text { font-size: 16px; color: #9ca3af; }
        .debug-text { font-size: 12px; color: #4b5563; margin-top: 5px;}
        .accuracy-bar { width: 200px; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-top: 10px; overflow: hidden; display: none; }
        .accuracy-fill { height: 100%; background: #22c55e; width: 0%; transition: width 0.1s; }

        .btn-group { display: flex; gap: 10px; }

        .game-btn {
            pointer-events: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            color: white;
        }
        .game-btn:active { transform: scale(0.95); }

        .btn-retry { background: rgba(239, 68, 68, 0.2); color: #fca5a5; border-color: rgba(239, 68, 68, 0.5); }
        .btn-retry:hover { background: rgba(239, 68, 68, 0.8); color: white; }

        .btn-skip { background: rgba(59, 130, 246, 0.2); color: #93c5fd; border-color: rgba(59, 130, 246, 0.5); }
        .btn-skip:hover { background: rgba(59, 130, 246, 0.8); color: white; }

        .instruction { color: rgba(255,255,255,0.7); text-align: center; font-size: 16px; margin-bottom: 20px; background: rgba(0,0,0,0.3); padding: 10px 20px; border-radius: 999px; align-self: center; pointer-events: auto; cursor: pointer; backdrop-filter: blur(2px);}
        
        #win-message { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            font-size: 4rem; color: #4ade80; font-weight: 900; 
            text-shadow: 0 0 30px rgba(74, 222, 128, 0.6); 
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
            text-align: center; white-space: nowrap; z-index: 20;
        }

        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #0f172a; z-index: 50; display: flex; align-items: center; justify-content: center;
            color: white; font-size: 20px; flex-direction: column;
        }
        .spinner { border: 4px solid rgba(255,255,255,0.1); border-left-color: #fbbf24; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="loading-screen">
    <div class="spinner"></div>
    <div id="loading-text">加载物理引擎...</div>
</div>

<div id="game-container">
    <div id="win-message">PERFECT!</div>
    <div id="ui-layer">
        <div class="top-bar">
            <div class="score-board">
                <div class="level-text">Level <span id="level-display">1</span></div>
                <div class="time-text">Time: <span id="timer-display">0.0</span>s</div>
                <div class="debug-text">Req: >95% Overlap</div>
                <div class="accuracy-bar" id="acc-bar"><div class="accuracy-fill" id="acc-fill"></div></div>
            </div>
            
            <div class="btn-group">
                <!-- 重置按钮：恢复当前关卡初始状态 -->
                <button onclick="retryCurrentLevel()" class="game-btn btn-retry">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                    重置
                </button>
                <!-- 跳过按钮：生成新关卡 -->
                <button onclick="startNewLevel()" class="game-btn btn-skip">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M13 5l7 7-7 7M5 5l7 7-7 7" />
                    </svg>
                    跳过
                </button>
            </div>
        </div>

        <div class="instruction" onclick="toggleInstruction()">
            要求：必须将方块与虚线框<br><b>精准重合 (95%+)</b> 才能吸附
        </div>
    </div>
</div>

<script>
    // --- 游戏引擎配置 ---
    const LOGICAL_SIZE = 1000; 
    const ARENA_SIZE = 800;    
    const CENTER = LOGICAL_SIZE / 2;
    
    const ENGINE_CONFIG = {
        wallThickness: 100,
        playerSize: 25, 
        blockSize: 35, 
        winDistance: 5.0, 
        winAngle: 0.08, 
    };

    const TETROMINOS = {
        'I': { color: '#22d3ee', symmetry: Math.PI, blocks: [{x:-1.5, y:0}, {x:-0.5, y:0}, {x:0.5, y:0}, {x:1.5, y:0}] },
        'J': { color: '#3b82f6', symmetry: Math.PI * 2, blocks: [{x:-1, y:-0.5}, {x:0, y:-0.5}, {x:1, y:-0.5}, {x:1, y:0.5}] },
        'L': { color: '#f59e0b', symmetry: Math.PI * 2, blocks: [{x:-1, y:0.5}, {x:-1, y:-0.5}, {x:0, y:-0.5}, {x:1, y:-0.5}] },
        'O': { color: '#eab308', symmetry: Math.PI / 2, blocks: [{x:-0.5, y:-0.5}, {x:0.5, y:-0.5}, {x:-0.5, y:0.5}, {x:0.5, y:0.5}] },
        'S': { color: '#22c55e', symmetry: Math.PI, blocks: [{x:-0.5, y:0.5}, {x:0.5, y:0.5}, {x:0.5, y:-0.5}, {x:1.5, y:-0.5}] },
        'T': { color: '#a855f7', symmetry: Math.PI * 2, blocks: [{x:-0.5, y:-0.5}, {x:0.5, y:-0.5}, {x:1.5, y:-0.5}, {x:0.5, y:0.5}] },
        'Z': { color: '#ef4444', symmetry: Math.PI, blocks: [{x:-1.5, y:-0.5}, {x:-0.5, y:-0.5}, {x:-0.5, y:0.5}, {x:0.5, y:0.5}] }
    };

    Object.keys(TETROMINOS).forEach(key => {
        const blocks = TETROMINOS[key].blocks;
        let sumX = 0, sumY = 0;
        blocks.forEach(b => { sumX += b.x; sumY += b.y; });
        TETROMINOS[key].offset = {
            x: sumX / blocks.length,
            y: sumY / blocks.length
        };
    });

    let Engine, Render, Runner, Bodies, Body, Composite, Events, Vector;
    let engine, render, runner;
    let playerBody, activeTetrominoBody = null, targetZone = null;
    let isDragging = false;
    let screenMouse = { x: 0, y: 0 };
    let worldMouse = { x: 0, y: 0 };
    let level = 1, startTime = Date.now(), isWinning = false;
    
    // --- 新增：保存当前关卡的初始状态 ---
    let currentLevelState = {
        playerStart: { x: 0, y: 0 },
        blockStart: { x: 0, y: 0 },
        blockType: 'I',
        // targetZone 是全局的，不需要额外存，除非我们想支持撤销
    };

    function checkResourcesAndInit() {
        if (typeof Matter === 'undefined') {
            document.getElementById('loading-text').innerText = "加载失败: 无法连接 CDN。\n请尝试刷新或检查网络。";
            document.getElementById('loading-text').style.color = "#ef4444";
            return;
        }
        Engine = Matter.Engine;
        Render = Matter.Render;
        Runner = Matter.Runner;
        Bodies = Matter.Bodies;
        Body = Matter.Body;
        Composite = Matter.Composite;
        Events = Matter.Events;
        Vector = Matter.Vector;
        initGame();
    }

    function initGame() {
        const container = document.getElementById('game-container');
        const loadingScreen = document.getElementById('loading-screen');
        
        if (container.clientWidth === 0) { setTimeout(initGame, 100); return; }
        loadingScreen.style.opacity = 0;
        setTimeout(() => loadingScreen.style.display = 'none', 500);

        engine = Engine.create({ gravity: { x: 0, y: 0, scale: 0 } });

        render = Render.create({
            element: container,
            engine: engine,
            options: {
                width: container.clientWidth,
                height: container.clientHeight,
                wireframes: false,
                background: '#0f172a',
                pixelRatio: Math.min(window.devicePixelRatio, 2),
                hasBounds: true 
            }
        });

        createFixedWalls();

        playerBody = Bodies.circle(CENTER, CENTER + 200, ENGINE_CONFIG.playerSize, {
            density: 0.005,
            frictionAir: 0.15,
            restitution: 0.4,
            render: { fillStyle: '#ffffff', strokeStyle: '#e5e7eb', lineWidth: 4 },
            label: 'Player'
        });
        Composite.add(engine.world, playerBody);

        setupInputs(render.canvas);
        setupEvents();

        Runner.run(Runner.create(), engine);
        Render.run(render);

        startNewLevel(); // 首次启动
        window.addEventListener('resize', updateViewport);
        updateViewport();
    }

    function updateViewport() {
        const container = document.getElementById('game-container');
        const w = container.clientWidth;
        const h = container.clientHeight;
        const pixelRatio = render.options.pixelRatio;

        render.canvas.width = w * pixelRatio;
        render.canvas.height = h * pixelRatio;
        render.canvas.style.width = w + 'px';
        render.canvas.style.height = h + 'px';
        render.options.width = w;
        render.options.height = h;

        const padding = 0.9; 
        const minDimension = Math.min(w, h);
        const scaleFactor = (ARENA_SIZE / padding) / minDimension;
        
        const viewWidth = w * scaleFactor;
        const viewHeight = h * scaleFactor;

        render.bounds.min.x = CENTER - viewWidth / 2;
        render.bounds.max.x = CENTER + viewWidth / 2;
        render.bounds.min.y = CENTER - viewHeight / 2;
        render.bounds.max.y = CENTER + viewHeight / 2;
        
        updateMouseWorldPosition();
    }

    function createFixedWalls() {
        const thick = ENGINE_CONFIG.wallThickness;
        const wallColor = '#334155';
        const wallOpts = { isStatic: true, render: { fillStyle: wallColor } };
        const half = ARENA_SIZE / 2;
        
        const walls = [
            Bodies.rectangle(CENTER, CENTER - half - thick/2, ARENA_SIZE + thick*2, thick, wallOpts),
            Bodies.rectangle(CENTER, CENTER + half + thick/2, ARENA_SIZE + thick*2, thick, wallOpts),
            Bodies.rectangle(CENTER - half - thick/2, CENTER, thick, ARENA_SIZE, wallOpts),
            Bodies.rectangle(CENTER + half + thick/2, CENTER, thick, ARENA_SIZE, wallOpts)
        ];
        Composite.add(engine.world, walls);
    }

    function setupInputs(canvas) {
        const handleInput = (e) => {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            screenMouse.x = x;
            screenMouse.y = y;
            isDragging = (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'touchmove' || (e.type === 'mousemove' && isDragging));
            
            if (e.type === 'mouseup' || e.type === 'touchend') {
                isDragging = false;
            }
            
            updateMouseWorldPosition();
        };

        canvas.addEventListener('mousedown', (e) => { isDragging = true; handleInput(e); });
        window.addEventListener('mousemove', handleInput);
        window.addEventListener('mouseup', (e) => { isDragging = false; });
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); isDragging = true; handleInput(e); }, {passive: false});
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleInput(e); }, {passive: false});
        canvas.addEventListener('touchend', (e) => { isDragging = false; });
    }

    function updateMouseWorldPosition() {
        if (!render) return;
        const container = document.getElementById('game-container');
        const w = container.clientWidth;
        const h = container.clientHeight;
        const bounds = render.bounds;
        const scaleX = (bounds.max.x - bounds.min.x) / w;
        const scaleY = (bounds.max.y - bounds.min.y) / h;
        worldMouse.x = bounds.min.x + screenMouse.x * scaleX;
        worldMouse.y = bounds.min.y + screenMouse.y * scaleY;
    }

    function setupEvents() {
        Events.on(engine, 'beforeUpdate', function() {
            engine.world.gravity.scale = 0;
            if (isDragging && playerBody) {
                const forceVector = Vector.sub(worldMouse, playerBody.position);
                const forceMagnitude = Vector.magnitude(forceVector);
                const maxForce = 0.005 * playerBody.mass;
                const normalizedForce = Vector.normalise(forceVector);
                const appliedForce = Vector.mult(normalizedForce, Math.min(forceMagnitude * 0.0015, maxForce));
                Body.applyForce(playerBody, playerBody.position, appliedForce);
            }
            checkWinCondition();
        });

        Events.on(engine, 'afterUpdate', function() {
            const margin = ENGINE_CONFIG.wallThickness + 50;
            const min = CENTER - ARENA_SIZE/2 - margin;
            const max = CENTER + ARENA_SIZE/2 + margin;
            function check(body) {
                if(!body) return;
                if(body.position.x < min || body.position.x > max || body.position.y < min || body.position.y > max) {
                    Body.setPosition(body, {x: CENTER, y: CENTER});
                    Body.setVelocity(body, {x:0, y:0});
                }
            }
            check(playerBody);
            check(activeTetrominoBody);
        });

        Events.on(render, 'afterRender', function() {
            const ctx = render.context;
            Render.startViewTransform(render);
            renderOverlay(ctx);
            Render.endViewTransform(render);
            if (!isWinning) {
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                document.getElementById('timer-display').innerText = elapsed;
            }
        });
    }

    function renderOverlay(ctx) {
        if (!targetZone) return;

        ctx.save();
        ctx.translate(targetZone.x, targetZone.y);
        ctx.rotate(targetZone.angle);
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.lineWidth = 2; 
        ctx.setLineDash([8, 6]); 
        
        const type = targetZone.type;
        const config = TETROMINOS[type];
        const blocks = config.blocks;
        const offset = config.offset; 
        const size = ENGINE_CONFIG.blockSize; 

        blocks.forEach(block => {
            const bx = (block.x - offset.x) * size;
            const by = (block.y - offset.y) * size;
            ctx.strokeRect(bx - size/2, by - size/2, size, size);
            ctx.fillStyle = config.color + '22'; 
            ctx.fillRect(bx - size/2, by - size/2, size, size);
        });
        ctx.restore();
        
        if (isDragging) {
            ctx.beginPath();
            ctx.moveTo(playerBody.position.x, playerBody.position.y);
            ctx.lineTo(worldMouse.x, worldMouse.y);
            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([]);
            ctx.stroke();
        }
    }

    function createPolyomino(x, y, type) {
        const config = TETROMINOS[type];
        const parts = [];
        config.blocks.forEach(b => {
            parts.push(Bodies.rectangle(
                x + b.x * ENGINE_CONFIG.blockSize, 
                y + b.y * ENGINE_CONFIG.blockSize, 
                ENGINE_CONFIG.blockSize, 
                ENGINE_CONFIG.blockSize,
                { render: { fillStyle: config.color, strokeStyle: '#000', lineWidth: 1 } }
            ));
        });
        return Body.create({
            parts: parts,
            frictionAir: 0.1, 
            restitution: 0.1, 
            density: 0.002,
            label: 'Tetromino'
        });
    }

    // --- 重置功能 (Retry) ---
    function retryCurrentLevel() {
        // 恢复 UI 状态
        isWinning = false;
        document.getElementById('win-message').style.opacity = 0;
        document.getElementById('acc-bar').style.display = 'block';
        
        // 1. 清理当前方块
        Composite.allBodies(engine.world).forEach(b => {
            if (b.label === 'Tetromino') Composite.remove(engine.world, b);
        });

        // 2. 还原玩家位置
        Body.setPosition(playerBody, currentLevelState.playerStart);
        Body.setVelocity(playerBody, { x: 0, y: 0 });
        Body.setAngularVelocity(playerBody, 0);

        // 3. 还原方块位置 (生成一个新的，但在原位置)
        activeTetrominoBody = createPolyomino(currentLevelState.blockStart.x, currentLevelState.blockStart.y, currentLevelState.blockType);
        // 重要：角度随机是在 startNewLevel 定的，如果要完全重置，也应该保存初始角度。
        // 这里为了简单，重置时方块角度会再次随机旋转（增加一点点变数），
        // 如果想要“完全一样”，需要在 state 里存 angle。让我们把它做得更完美一点：
        // 修改：使用保存的初始角度。
        Body.setAngle(activeTetrominoBody, currentLevelState.blockInitialAngle);
        
        Composite.add(engine.world, activeTetrominoBody);
        
        // 重置时间
        startTime = Date.now();
    }

    // --- 新关卡功能 (Skip/Next) ---
    function startNewLevel() {
        isWinning = false;
        document.getElementById('win-message').style.opacity = 0;
        document.getElementById('acc-bar').style.display = 'block'; 
        document.getElementById('level-display').innerText = level;

        Composite.allBodies(engine.world).forEach(b => {
            if (b.label === 'Tetromino') Composite.remove(engine.world, b);
        });

        const spawnMargin = 150; 
        const range = ARENA_SIZE / 2 - spawnMargin;

        // 1. 生成随机位置
        const playerX = CENTER + (Math.random() - 0.5) * 2 * range;
        const playerY = CENTER + (Math.random() - 0.5) * 2 * range;

        // 2. 生成目标
        const keys = Object.keys(TETROMINOS);
        const type = keys[Math.floor(Math.random() * keys.length)];
        const targetX = CENTER + (Math.random() - 0.5) * 2 * range;
        const targetY = CENTER + (Math.random() - 0.5) * 2 * range; 
        const targetAngle = (Math.floor(Math.random() * 4) * 90) * (Math.PI / 180);

        targetZone = { x: targetX, y: targetY, angle: targetAngle, type: type };

        // 3. 生成方块起始位置
        let startX, startY, isSafe = false, attempts = 0;
        while (!isSafe && attempts < 50) {
            startX = CENTER + (Math.random() - 0.5) * 2 * range;
            startY = CENTER + (Math.random() - 0.5) * 2 * range;
            const distP = Math.hypot(startX - playerX, startY - playerY);
            const distT = Math.hypot(startX - targetX, startY - targetY);
            if (distP > 150 && distT > 150) isSafe = true;
            attempts++;
        }
        
        const initialAngle = Math.random() * Math.PI * 2;

        // --- 存档 (Save State) ---
        currentLevelState = {
            playerStart: { x: playerX, y: playerY },
            blockStart: { x: startX, y: startY },
            blockType: type,
            blockInitialAngle: initialAngle
        };

        // 应用位置
        Body.setPosition(playerBody, { x: playerX, y: playerY });
        Body.setVelocity(playerBody, { x: 0, y: 0 });
        Body.setAngularVelocity(playerBody, 0);

        activeTetrominoBody = createPolyomino(startX, startY, type);
        Body.setAngle(activeTetrominoBody, initialAngle);
        Composite.add(engine.world, activeTetrominoBody);
        
        startTime = Date.now();
    }

    function checkWinCondition() {
        if (isWinning || !activeTetrominoBody || !targetZone) return;

        const pos = activeTetrominoBody.position;
        const dist = Vector.magnitude(Vector.sub(pos, {x: targetZone.x, y: targetZone.y}));
        
        let currentAngle = activeTetrominoBody.angle;
        let targetA = targetZone.angle;
        const symmetry = TETROMINOS[targetZone.type].symmetry;
        
        let angleDiff = Math.abs(currentAngle - targetA);
        angleDiff = angleDiff % symmetry;
        if (angleDiff > symmetry / 2) {
            angleDiff = symmetry - angleDiff;
        }

        const speed = Vector.magnitude(activeTetrominoBody.velocity);
        const angularSpeed = Math.abs(activeTetrominoBody.angularVelocity);

        const accuracy = Math.max(0, 1 - (dist / 100) - (angleDiff / 1.0));
        const barFill = document.getElementById('acc-fill');
        if(barFill) barFill.style.width = (accuracy * 100) + '%';
        if(accuracy > 0.9) barFill.style.background = '#4ade80';
        else barFill.style.background = '#ef4444';

        if (dist < ENGINE_CONFIG.winDistance && angleDiff < ENGINE_CONFIG.winAngle && speed < 1.0 && angularSpeed < 0.05) {
             victory();
        }
    }

    function victory() {
        isWinning = true;
        document.getElementById('win-message').style.opacity = 1;
        document.getElementById('acc-bar').style.display = 'none';
        
        Body.setPosition(activeTetrominoBody, {x: targetZone.x, y: targetZone.y});
        Body.setAngle(activeTetrominoBody, targetZone.angle);
        Body.setStatic(activeTetrominoBody, true); 
        activeTetrominoBody.render.opacity = 0.5;

        setTimeout(() => {
            level++;
            startNewLevel();
        }, 2000); 
    }

    function toggleInstruction() {
        document.querySelector('.instruction').style.display = 'none';
    }

    window.onload = checkResourcesAndInit;

</script>
</body>
</html>
